// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lcs.proto

#ifndef PROTOBUF_lcs_2eproto__INCLUDED
#define PROTOBUF_lcs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
// @@protoc_insertion_point(includes)

namespace dragoon {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_lcs_2eproto();
void protobuf_AssignDesc_lcs_2eproto();
void protobuf_ShutdownFile_lcs_2eproto();

class CellMessage;
class TmsiMessage;
class UsrpMessage;
class NulMessage;
class ResultMessage;
class LogMessage;
class AirTypeMessage;
class GainMessage;

enum AirType {
  GSM = 0,
  WCDMA = 1,
  TDSCDMA = 2,
  CDMA2000 = 3
};
bool AirType_IsValid(int value);
const AirType AirType_MIN = GSM;
const AirType AirType_MAX = CDMA2000;
const int AirType_ARRAYSIZE = AirType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AirType_descriptor();
inline const ::std::string& AirType_Name(AirType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AirType_descriptor(), value);
}
inline bool AirType_Parse(
    const ::std::string& name, AirType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AirType>(
    AirType_descriptor(), name, value);
}
// ===================================================================

class CellMessage : public ::google::protobuf::Message {
 public:
  CellMessage();
  virtual ~CellMessage();
  
  CellMessage(const CellMessage& from);
  
  inline CellMessage& operator=(const CellMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CellMessage& default_instance();
  
  void Swap(CellMessage* other);
  
  // implements Message ----------------------------------------------
  
  CellMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellMessage& from);
  void MergeFrom(const CellMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ant = 1;
  inline bool has_ant() const;
  inline void clear_ant();
  static const int kAntFieldNumber = 1;
  inline ::google::protobuf::int32 ant() const;
  inline void set_ant(::google::protobuf::int32 value);
  
  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required int32 freq = 3;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 3;
  inline ::google::protobuf::int32 freq() const;
  inline void set_freq(::google::protobuf::int32 value);
  
  // required int32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);
  
  // required int32 energy = 5;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 5;
  inline ::google::protobuf::int32 energy() const;
  inline void set_energy(::google::protobuf::int32 value);
  
  // repeated string nb = 6;
  inline int nb_size() const;
  inline void clear_nb();
  static const int kNbFieldNumber = 6;
  inline const ::std::string& nb(int index) const;
  inline ::std::string* mutable_nb(int index);
  inline void set_nb(int index, const ::std::string& value);
  inline void set_nb(int index, const char* value);
  inline void set_nb(int index, const char* value, size_t size);
  inline ::std::string* add_nb();
  inline void add_nb(const ::std::string& value);
  inline void add_nb(const char* value);
  inline void add_nb(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nb() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nb();
  
  // optional string lac = 7;
  inline bool has_lac() const;
  inline void clear_lac();
  static const int kLacFieldNumber = 7;
  inline const ::std::string& lac() const;
  inline void set_lac(const ::std::string& value);
  inline void set_lac(const char* value);
  inline void set_lac(const char* value, size_t size);
  inline ::std::string* mutable_lac();
  inline ::std::string* release_lac();
  
  // @@protoc_insertion_point(class_scope:dragoon.CellMessage)
 private:
  inline void set_has_ant();
  inline void clear_has_ant();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_freq();
  inline void clear_has_freq();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_lac();
  inline void clear_has_lac();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::int32 ant_;
  ::google::protobuf::int32 freq_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 energy_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nb_;
  ::std::string* lac_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_lcs_2eproto();
  friend void protobuf_AssignDesc_lcs_2eproto();
  friend void protobuf_ShutdownFile_lcs_2eproto();
  
  void InitAsDefaultInstance();
  static CellMessage* default_instance_;
};
// -------------------------------------------------------------------

class TmsiMessage : public ::google::protobuf::Message {
 public:
  TmsiMessage();
  virtual ~TmsiMessage();
  
  TmsiMessage(const TmsiMessage& from);
  
  inline TmsiMessage& operator=(const TmsiMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TmsiMessage& default_instance();
  
  void Swap(TmsiMessage* other);
  
  // implements Message ----------------------------------------------
  
  TmsiMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TmsiMessage& from);
  void MergeFrom(const TmsiMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ant = 1;
  inline bool has_ant() const;
  inline void clear_ant();
  static const int kAntFieldNumber = 1;
  inline ::google::protobuf::int32 ant() const;
  inline void set_ant(::google::protobuf::int32 value);
  
  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string cell = 3;
  inline bool has_cell() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 3;
  inline const ::std::string& cell() const;
  inline void set_cell(const ::std::string& value);
  inline void set_cell(const char* value);
  inline void set_cell(const char* value, size_t size);
  inline ::std::string* mutable_cell();
  inline ::std::string* release_cell();
  
  // required int32 rssi = 4;
  inline bool has_rssi() const;
  inline void clear_rssi();
  static const int kRssiFieldNumber = 4;
  inline ::google::protobuf::int32 rssi() const;
  inline void set_rssi(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dragoon.TmsiMessage)
 private:
  inline void set_has_ant();
  inline void clear_has_ant();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cell();
  inline void clear_has_cell();
  inline void set_has_rssi();
  inline void clear_has_rssi();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::int32 ant_;
  ::google::protobuf::int32 rssi_;
  ::std::string* cell_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_lcs_2eproto();
  friend void protobuf_AssignDesc_lcs_2eproto();
  friend void protobuf_ShutdownFile_lcs_2eproto();
  
  void InitAsDefaultInstance();
  static TmsiMessage* default_instance_;
};
// -------------------------------------------------------------------

class UsrpMessage : public ::google::protobuf::Message {
 public:
  UsrpMessage();
  virtual ~UsrpMessage();
  
  UsrpMessage(const UsrpMessage& from);
  
  inline UsrpMessage& operator=(const UsrpMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UsrpMessage& default_instance();
  
  void Swap(UsrpMessage* other);
  
  // implements Message ----------------------------------------------
  
  UsrpMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UsrpMessage& from);
  void MergeFrom(const UsrpMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ant = 1;
  inline bool has_ant() const;
  inline void clear_ant();
  static const int kAntFieldNumber = 1;
  inline ::google::protobuf::int32 ant() const;
  inline void set_ant(::google::protobuf::int32 value);
  
  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // @@protoc_insertion_point(class_scope:dragoon.UsrpMessage)
 private:
  inline void set_has_ant();
  inline void clear_has_ant();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::int32 ant_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_lcs_2eproto();
  friend void protobuf_AssignDesc_lcs_2eproto();
  friend void protobuf_ShutdownFile_lcs_2eproto();
  
  void InitAsDefaultInstance();
  static UsrpMessage* default_instance_;
};
// -------------------------------------------------------------------

class NulMessage : public ::google::protobuf::Message {
 public:
  NulMessage();
  virtual ~NulMessage();
  
  NulMessage(const NulMessage& from);
  
  inline NulMessage& operator=(const NulMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NulMessage& default_instance();
  
  void Swap(NulMessage* other);
  
  // implements Message ----------------------------------------------
  
  NulMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NulMessage& from);
  void MergeFrom(const NulMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:dragoon.NulMessage)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_lcs_2eproto();
  friend void protobuf_AssignDesc_lcs_2eproto();
  friend void protobuf_ShutdownFile_lcs_2eproto();
  
  void InitAsDefaultInstance();
  static NulMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResultMessage : public ::google::protobuf::Message {
 public:
  ResultMessage();
  virtual ~ResultMessage();
  
  ResultMessage(const ResultMessage& from);
  
  inline ResultMessage& operator=(const ResultMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultMessage& default_instance();
  
  void Swap(ResultMessage* other);
  
  // implements Message ----------------------------------------------
  
  ResultMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultMessage& from);
  void MergeFrom(const ResultMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 r = 1;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 1;
  inline ::google::protobuf::int32 r() const;
  inline void set_r(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dragoon.ResultMessage)
 private:
  inline void set_has_r();
  inline void clear_has_r();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 r_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_lcs_2eproto();
  friend void protobuf_AssignDesc_lcs_2eproto();
  friend void protobuf_ShutdownFile_lcs_2eproto();
  
  void InitAsDefaultInstance();
  static ResultMessage* default_instance_;
};
// -------------------------------------------------------------------

class LogMessage : public ::google::protobuf::Message {
 public:
  LogMessage();
  virtual ~LogMessage();
  
  LogMessage(const LogMessage& from);
  
  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMessage& default_instance();
  
  void Swap(LogMessage* other);
  
  // implements Message ----------------------------------------------
  
  LogMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ant = 1;
  inline bool has_ant() const;
  inline void clear_ant();
  static const int kAntFieldNumber = 1;
  inline ::google::protobuf::int32 ant() const;
  inline void set_ant(::google::protobuf::int32 value);
  
  // required int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // optional string error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  
  // @@protoc_insertion_point(class_scope:dragoon.LogMessage)
 private:
  inline void set_has_ant();
  inline void clear_has_ant();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 ant_;
  ::google::protobuf::int32 code_;
  ::std::string* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_lcs_2eproto();
  friend void protobuf_AssignDesc_lcs_2eproto();
  friend void protobuf_ShutdownFile_lcs_2eproto();
  
  void InitAsDefaultInstance();
  static LogMessage* default_instance_;
};
// -------------------------------------------------------------------

class AirTypeMessage : public ::google::protobuf::Message {
 public:
  AirTypeMessage();
  virtual ~AirTypeMessage();
  
  AirTypeMessage(const AirTypeMessage& from);
  
  inline AirTypeMessage& operator=(const AirTypeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AirTypeMessage& default_instance();
  
  void Swap(AirTypeMessage* other);
  
  // implements Message ----------------------------------------------
  
  AirTypeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AirTypeMessage& from);
  void MergeFrom(const AirTypeMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dragoon.AirType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline dragoon::AirType type() const;
  inline void set_type(dragoon::AirType value);
  
  // @@protoc_insertion_point(class_scope:dragoon.AirTypeMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_lcs_2eproto();
  friend void protobuf_AssignDesc_lcs_2eproto();
  friend void protobuf_ShutdownFile_lcs_2eproto();
  
  void InitAsDefaultInstance();
  static AirTypeMessage* default_instance_;
};
// -------------------------------------------------------------------

class GainMessage : public ::google::protobuf::Message {
 public:
  GainMessage();
  virtual ~GainMessage();
  
  GainMessage(const GainMessage& from);
  
  inline GainMessage& operator=(const GainMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GainMessage& default_instance();
  
  void Swap(GainMessage* other);
  
  // implements Message ----------------------------------------------
  
  GainMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GainMessage& from);
  void MergeFrom(const GainMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double gain = 1;
  inline bool has_gain() const;
  inline void clear_gain();
  static const int kGainFieldNumber = 1;
  inline double gain() const;
  inline void set_gain(double value);
  
  // @@protoc_insertion_point(class_scope:dragoon.GainMessage)
 private:
  inline void set_has_gain();
  inline void clear_has_gain();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double gain_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_lcs_2eproto();
  friend void protobuf_AssignDesc_lcs_2eproto();
  friend void protobuf_ShutdownFile_lcs_2eproto();
  
  void InitAsDefaultInstance();
  static GainMessage* default_instance_;
};
// ===================================================================

class LocaterService_Stub;

class LocaterService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline LocaterService() {};
 public:
  virtual ~LocaterService();
  
  typedef LocaterService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void SendUsrp(::google::protobuf::RpcController* controller,
                       const ::dragoon::UsrpMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void SendTmsi(::google::protobuf::RpcController* controller,
                       const ::dragoon::TmsiMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void SendCell(::google::protobuf::RpcController* controller,
                       const ::dragoon::CellMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void SendLog(::google::protobuf::RpcController* controller,
                       const ::dragoon::LogMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(LocaterService);
};

class LocaterService_Stub : public LocaterService {
 public:
  LocaterService_Stub(::google::protobuf::RpcChannel* channel);
  LocaterService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~LocaterService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements LocaterService ------------------------------------------
  
  void SendUsrp(::google::protobuf::RpcController* controller,
                       const ::dragoon::UsrpMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void SendTmsi(::google::protobuf::RpcController* controller,
                       const ::dragoon::TmsiMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void SendCell(::google::protobuf::RpcController* controller,
                       const ::dragoon::CellMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void SendLog(::google::protobuf::RpcController* controller,
                       const ::dragoon::LogMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(LocaterService_Stub);
};


// -------------------------------------------------------------------

class UsrperService_Stub;

class UsrperService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline UsrperService() {};
 public:
  virtual ~UsrperService();
  
  typedef UsrperService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void Init(::google::protobuf::RpcController* controller,
                       const ::dragoon::AirTypeMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void ScanCell(::google::protobuf::RpcController* controller,
                       const ::dragoon::NulMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void SetGain(::google::protobuf::RpcController* controller,
                       const ::dragoon::GainMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void Listen(::google::protobuf::RpcController* controller,
                       const ::dragoon::CellMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void Locate(::google::protobuf::RpcController* controller,
                       const ::dragoon::TmsiMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void Stop(::google::protobuf::RpcController* controller,
                       const ::dragoon::NulMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void Release(::google::protobuf::RpcController* controller,
                       const ::dragoon::NulMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(UsrperService);
};

class UsrperService_Stub : public UsrperService {
 public:
  UsrperService_Stub(::google::protobuf::RpcChannel* channel);
  UsrperService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~UsrperService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements UsrperService ------------------------------------------
  
  void Init(::google::protobuf::RpcController* controller,
                       const ::dragoon::AirTypeMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void ScanCell(::google::protobuf::RpcController* controller,
                       const ::dragoon::NulMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void SetGain(::google::protobuf::RpcController* controller,
                       const ::dragoon::GainMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void Listen(::google::protobuf::RpcController* controller,
                       const ::dragoon::CellMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void Locate(::google::protobuf::RpcController* controller,
                       const ::dragoon::TmsiMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void Stop(::google::protobuf::RpcController* controller,
                       const ::dragoon::NulMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
  void Release(::google::protobuf::RpcController* controller,
                       const ::dragoon::NulMessage* request,
                       ::dragoon::ResultMessage* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(UsrperService_Stub);
};


// ===================================================================


// ===================================================================

// CellMessage

// required int32 ant = 1;
inline bool CellMessage::has_ant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellMessage::set_has_ant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellMessage::clear_has_ant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellMessage::clear_ant() {
  ant_ = 0;
  clear_has_ant();
}
inline ::google::protobuf::int32 CellMessage::ant() const {
  return ant_;
}
inline void CellMessage::set_ant(::google::protobuf::int32 value) {
  set_has_ant();
  ant_ = value;
}

// required string id = 2;
inline bool CellMessage::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellMessage::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellMessage::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CellMessage::id() const {
  return *id_;
}
inline void CellMessage::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CellMessage::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CellMessage::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CellMessage::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CellMessage::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 freq = 3;
inline bool CellMessage::has_freq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CellMessage::set_has_freq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CellMessage::clear_has_freq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CellMessage::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline ::google::protobuf::int32 CellMessage::freq() const {
  return freq_;
}
inline void CellMessage::set_freq(::google::protobuf::int32 value) {
  set_has_freq();
  freq_ = value;
}

// required int32 index = 4;
inline bool CellMessage::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CellMessage::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CellMessage::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CellMessage::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 CellMessage::index() const {
  return index_;
}
inline void CellMessage::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required int32 energy = 5;
inline bool CellMessage::has_energy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CellMessage::set_has_energy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CellMessage::clear_has_energy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CellMessage::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 CellMessage::energy() const {
  return energy_;
}
inline void CellMessage::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
}

// repeated string nb = 6;
inline int CellMessage::nb_size() const {
  return nb_.size();
}
inline void CellMessage::clear_nb() {
  nb_.Clear();
}
inline const ::std::string& CellMessage::nb(int index) const {
  return nb_.Get(index);
}
inline ::std::string* CellMessage::mutable_nb(int index) {
  return nb_.Mutable(index);
}
inline void CellMessage::set_nb(int index, const ::std::string& value) {
  nb_.Mutable(index)->assign(value);
}
inline void CellMessage::set_nb(int index, const char* value) {
  nb_.Mutable(index)->assign(value);
}
inline void CellMessage::set_nb(int index, const char* value, size_t size) {
  nb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CellMessage::add_nb() {
  return nb_.Add();
}
inline void CellMessage::add_nb(const ::std::string& value) {
  nb_.Add()->assign(value);
}
inline void CellMessage::add_nb(const char* value) {
  nb_.Add()->assign(value);
}
inline void CellMessage::add_nb(const char* value, size_t size) {
  nb_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CellMessage::nb() const {
  return nb_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CellMessage::mutable_nb() {
  return &nb_;
}

// optional string lac = 7;
inline bool CellMessage::has_lac() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CellMessage::set_has_lac() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CellMessage::clear_has_lac() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CellMessage::clear_lac() {
  if (lac_ != &::google::protobuf::internal::kEmptyString) {
    lac_->clear();
  }
  clear_has_lac();
}
inline const ::std::string& CellMessage::lac() const {
  return *lac_;
}
inline void CellMessage::set_lac(const ::std::string& value) {
  set_has_lac();
  if (lac_ == &::google::protobuf::internal::kEmptyString) {
    lac_ = new ::std::string;
  }
  lac_->assign(value);
}
inline void CellMessage::set_lac(const char* value) {
  set_has_lac();
  if (lac_ == &::google::protobuf::internal::kEmptyString) {
    lac_ = new ::std::string;
  }
  lac_->assign(value);
}
inline void CellMessage::set_lac(const char* value, size_t size) {
  set_has_lac();
  if (lac_ == &::google::protobuf::internal::kEmptyString) {
    lac_ = new ::std::string;
  }
  lac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CellMessage::mutable_lac() {
  set_has_lac();
  if (lac_ == &::google::protobuf::internal::kEmptyString) {
    lac_ = new ::std::string;
  }
  return lac_;
}
inline ::std::string* CellMessage::release_lac() {
  clear_has_lac();
  if (lac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lac_;
    lac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TmsiMessage

// required int32 ant = 1;
inline bool TmsiMessage::has_ant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TmsiMessage::set_has_ant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TmsiMessage::clear_has_ant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TmsiMessage::clear_ant() {
  ant_ = 0;
  clear_has_ant();
}
inline ::google::protobuf::int32 TmsiMessage::ant() const {
  return ant_;
}
inline void TmsiMessage::set_ant(::google::protobuf::int32 value) {
  set_has_ant();
  ant_ = value;
}

// required string id = 2;
inline bool TmsiMessage::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TmsiMessage::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TmsiMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TmsiMessage::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TmsiMessage::id() const {
  return *id_;
}
inline void TmsiMessage::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TmsiMessage::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TmsiMessage::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TmsiMessage::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TmsiMessage::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string cell = 3;
inline bool TmsiMessage::has_cell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TmsiMessage::set_has_cell() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TmsiMessage::clear_has_cell() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TmsiMessage::clear_cell() {
  if (cell_ != &::google::protobuf::internal::kEmptyString) {
    cell_->clear();
  }
  clear_has_cell();
}
inline const ::std::string& TmsiMessage::cell() const {
  return *cell_;
}
inline void TmsiMessage::set_cell(const ::std::string& value) {
  set_has_cell();
  if (cell_ == &::google::protobuf::internal::kEmptyString) {
    cell_ = new ::std::string;
  }
  cell_->assign(value);
}
inline void TmsiMessage::set_cell(const char* value) {
  set_has_cell();
  if (cell_ == &::google::protobuf::internal::kEmptyString) {
    cell_ = new ::std::string;
  }
  cell_->assign(value);
}
inline void TmsiMessage::set_cell(const char* value, size_t size) {
  set_has_cell();
  if (cell_ == &::google::protobuf::internal::kEmptyString) {
    cell_ = new ::std::string;
  }
  cell_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TmsiMessage::mutable_cell() {
  set_has_cell();
  if (cell_ == &::google::protobuf::internal::kEmptyString) {
    cell_ = new ::std::string;
  }
  return cell_;
}
inline ::std::string* TmsiMessage::release_cell() {
  clear_has_cell();
  if (cell_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cell_;
    cell_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 rssi = 4;
inline bool TmsiMessage::has_rssi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TmsiMessage::set_has_rssi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TmsiMessage::clear_has_rssi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TmsiMessage::clear_rssi() {
  rssi_ = 0;
  clear_has_rssi();
}
inline ::google::protobuf::int32 TmsiMessage::rssi() const {
  return rssi_;
}
inline void TmsiMessage::set_rssi(::google::protobuf::int32 value) {
  set_has_rssi();
  rssi_ = value;
}

// -------------------------------------------------------------------

// UsrpMessage

// required int32 ant = 1;
inline bool UsrpMessage::has_ant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsrpMessage::set_has_ant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UsrpMessage::clear_has_ant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UsrpMessage::clear_ant() {
  ant_ = 0;
  clear_has_ant();
}
inline ::google::protobuf::int32 UsrpMessage::ant() const {
  return ant_;
}
inline void UsrpMessage::set_ant(::google::protobuf::int32 value) {
  set_has_ant();
  ant_ = value;
}

// required string id = 2;
inline bool UsrpMessage::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UsrpMessage::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UsrpMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UsrpMessage::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& UsrpMessage::id() const {
  return *id_;
}
inline void UsrpMessage::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void UsrpMessage::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void UsrpMessage::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UsrpMessage::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* UsrpMessage::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NulMessage

// -------------------------------------------------------------------

// ResultMessage

// optional int32 r = 1;
inline bool ResultMessage::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultMessage::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultMessage::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultMessage::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline ::google::protobuf::int32 ResultMessage::r() const {
  return r_;
}
inline void ResultMessage::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
}

// -------------------------------------------------------------------

// LogMessage

// required int32 ant = 1;
inline bool LogMessage::has_ant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogMessage::set_has_ant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogMessage::clear_has_ant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogMessage::clear_ant() {
  ant_ = 0;
  clear_has_ant();
}
inline ::google::protobuf::int32 LogMessage::ant() const {
  return ant_;
}
inline void LogMessage::set_ant(::google::protobuf::int32 value) {
  set_has_ant();
  ant_ = value;
}

// required int32 code = 2;
inline bool LogMessage::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogMessage::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogMessage::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogMessage::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 LogMessage::code() const {
  return code_;
}
inline void LogMessage::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string error = 3;
inline bool LogMessage::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogMessage::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogMessage::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogMessage::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& LogMessage::error() const {
  return *error_;
}
inline void LogMessage::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void LogMessage::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void LogMessage::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogMessage::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* LogMessage::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AirTypeMessage

// required .dragoon.AirType type = 1;
inline bool AirTypeMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AirTypeMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AirTypeMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AirTypeMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline dragoon::AirType AirTypeMessage::type() const {
  return static_cast< dragoon::AirType >(type_);
}
inline void AirTypeMessage::set_type(dragoon::AirType value) {
  GOOGLE_DCHECK(dragoon::AirType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// GainMessage

// required double gain = 1;
inline bool GainMessage::has_gain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GainMessage::set_has_gain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GainMessage::clear_has_gain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GainMessage::clear_gain() {
  gain_ = 0;
  clear_has_gain();
}
inline double GainMessage::gain() const {
  return gain_;
}
inline void GainMessage::set_gain(double value) {
  set_has_gain();
  gain_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dragoon

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< dragoon::AirType>() {
  return dragoon::AirType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lcs_2eproto__INCLUDED
